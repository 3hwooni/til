# Glossary

## GoF의 디자인 패턴 1.6

> 객체지향 프로그램은 객체(object)로 만듭니다.

> 객체는 데이터와 이 데이터에 연산을 가하는 프로시저(procedure)를
> 함께 묶은 단위입니다.

> 프로시저를 일반적으로 메서드(method) 또는 연산(operation)이라고 합니다.

> 객체는 요청(request) 또는 메시지(message)를 사용자에게 받으면
> 연산을 수행합니다.

> 요청은 객체가 연산을 수행하게 하는 유일한 방법이고,
> 연산은 객체의 내부 데이터의 상태를 변경하는 유일한 방법입니다.
> 이러한 접근의 제약 사항으로 객체의 내부 상태는 캡슐화(encapsulate)된다고
> 말합니다.

> 객체가 선언하는 모든 연산은 연산의 이름, 매개변수로 받아들이는 객체들,
> 연산의 반환 값을 명세합니다.
> 이를 연산의 시그너처(signature)라고 합니다.

> 인터페이스(interface)는 객체가 정의하는 연산의 모든 시그너처들을 일컫는 말로
> 객체의 인터페이스는 객체가 받아서 처리할 수 있는 연산의 집합입니다.

> 타입(type)은 특정 인터페이스를 나타낼 때 사용하는 이름입니다.

> 인터페이스가 다른 인터페이스를 부분집합으로 포함할 때도 있는데,
> 다른 인터페이스를 포함하는 인터페이스를 서브타입(subtype)이라고 하고,
> 다른 인터페이스가 포함하는 인터페이스를 슈퍼타입(suptertype)이라 합니다.

> 서브타입은 슈퍼타입의 인터페이스를 상속한다고 이야기합니다.

> 어떤 요청과 그 요청을 처리할 객체를 프로그램 실행 중,
> 즉 런타임에 연결 짓는 것을 동적 바인딩(dynamic binding)이라고 합니다.

> 동적 바인딩은 프로그램이 기대하는 객체를 동일한 인터페이스를 갖는
> 다른 객체로 대체할 수 있게 해 줍니다.
> 이런 대체성을 우리는 다형성(polymorphism)이라고 하는데,
> 이는 객체지향 시스템의 핵심 개념입니다.

> 어떤 객체의 구현은 클래스(class)에서 정의(define)합니다.

> 객체는 클래스를 인스턴스로 만듦으로써 생성됩니다.
> 즉, 객체는 클래스의 인스턴스라고 할 수 있습니다.

> 클래스의 인스턴스화 과정은
> 객체의 내부 데이터(인스턴스 변수(instance variable))에 대한 공간을 할당하고,
> 이 데이터들을 연산과 관련짓는 것입니다.

> 새로운 클래스는 기존 클래스에 기반을 둔 클래스 상속을 사용하여
> 정의할 수 있습니다.
> 서브클래스(subclass)가 부모 클래스(parent class)를 상속하면,
> 부모 클래스가 갖는 모든 데이터와 연산을 서브클래스가 갖게 됩니다.

> 추상 클래스(abstract class)는 모든 서브클래스 사이의
> 공통되는 인터페이스를 정의합니다.

> 정의만 하고 구현하지 않는 연산을 추상 연산(abstract operation)이라 하고,
> 추상 클래스가 아닌 클래스를 구체 클래스(concrete class)라고 합니다.

> 오버라이드(override)로 서브클래스는 부모 클래스에 정의된 처리 방식을> 변경할 수 있습니다.

> 믹스인(mixin) 클래스는 다른 클래스들에게 선택적인 인터페이스 혹은 기능을
> 제공하려는 목적을 가진 클래스입니다.

> 믹스인 클래스를 사용하기 위해서는 다음 그림처럼 다중 상속이 필요합니다.

> 추상 클래스를 상속한다는 것은 단순한 코드의 재사용을 위한 상속이 아니라
> 추상 클래스가 정의하는 인터페이스를 상속하겠다는 의미입니다.

> 상속이 가진 다른 기능들 중에는 동일한 인터페이스를 갖는 객체군을
> 정의하는 것이 있는데, 매주 중요한 특징입니다.
> 객체군을 정의하는 것이 중요한 이유는
> 그것으로 다형성을 끌어낼 수 있기 때문입니다.

> **구현이 아닌 인터페이스에 따라 프로그래밍합니다.**

> 객체지향 시스템에서 기능의 재사용을 위해 구사하는 가장 대표적인 기법은
> 클래스 상속, 그리고 객체 합성(object composition)입니다.

> 클래스 상속보다 객체 합성을 더 선호하는 이유는
> 각 클래스의 캡슐화를 유지할 수 있고,
> 각 클래스의 한 가지 작업에 집중할 수 있기 때문입니다.

> **객체 합성이 클래스 상속보다 더 나은 방법입니다.**

> 위임(delegation)은 합성을 상속만큼 강력하게 만드는 방법입니다.
> 위임에서는 두 객체가 하나의 요청을 처리합니다.
> 수신 객체가 연산의 처리를 위해 위임자(delegate)에게 보냅니다.
> 이는 서브클래스가 부모 클래스에게 요청을 전달하는 것과 유사한 방식입니다.

> 기능의 재사용에 이용할 수 있는 다른 방법이
> 매개변수화된 타입(parameterized type)입니다.
> Ada와 Eiffel에서는 제네릭(generic)이라고 하며,
> C++에서는 템플릿(template)이라고 합니다.

> 객체 관계 중에는 집합(aggregation)과 인지(acquaintance)라는 것이 있습니다.

> 집합은 한 객체가 다른 객체를 소유하거나 그것에 책임을 진다는 뜻입니다.

> 객체 인지는 한 객체가 다른 객체에 대해 알고 있음(knows of)을 의미합니다.

> 툴킷이란 일반적인 목적의 유용한 기능을 제공하는 재사용 가능한
> 클래스들의 집합체입니다.

> 프레임워크(framework)는 특정 부류의 소프트웨어에 재사용성을 부여하여
> 개발할 수 있도록 만들어 주는 관련 클래스들의 집합입니다.

> 툴킷을 사용하여 응용프로그램을 작성할 때는,
> 여러분이 직접 응용프로그램의 주(main) 본문을 작성하고
> 여러분이 재사용하고자 하는 코드를 호출합니다.
> 그러나 프레임워크를 재사용할 때는
> 프레임워크가 제공하는 주 본문을 바로 재사용하고
> 이 부분에서 호출하는 코드를 여러분이 작성하는 것입니다.
