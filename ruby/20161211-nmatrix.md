- [2016년 한국 루비 커뮤니티 대림절 달력(Advent Calendar)](http://j.mp/1jL0Eir)
- 이전 글: 12월 10일, [루비 메서드 디스패치 시스템 이해하기 (Part 1)](http://j.mp/2hrF2s0)
- 다음 글: 12월 12일, [테스트 헬퍼 만들기](http://j.mp/2hjKUpw)

---

# NMatrix 맛보기

## 저자
[@ahastudio](http://j.mp/1ea27KW) - 코딩의 신[神]. Ruby on Rails로 여러 서비스를 오픈했고, 최근엔 Lean Startup과 Machine Learning을 공부하면서 가르치고 있습니다.

## 시작하며
빅데이터 관련 기술이 유행하고 있는 요즘, 선형대수의 활용은 선택이 아닌 필수가 되고 있습니다. Python에선 네이티브로 구현된 NumPy, SciPy가 오래 전부터 대세로 자리잡았고, Ruby에선 이에 대응하는 NMatrix, SciRuby가 있습니다.

여기서는 [NMatrix](http://j.mp/2hpU0ln)를 간단히 맛보도록 하겠습니다.

## 준비물
- Ruby
- 흥미
- 용기
- 사랑과 우정 (필수는 아님)

## NMatrix 설치

먼저, NMatrix는 루비 기본 라이브러리가 아니기 때문에 따로 설치해야 합니다.

```
$ gem install nmatrix
```

제 경우엔 `Gemfile`에 포함시켜서 사용합니다.

```ruby
source 'https://rubygems.org'

gem 'nmatrix'
```

준비가 끝났습니다.

## Array vs. Vector

최근 주목 받고 있는 R이나 Julia 같은 언어가 어떤 장점이 있는가? NMatrix를 쓰면 어떤 점이 좋은가?

가장 기본이 되는 상황을 간단히 살펴보죠. `(1 2 3)`과 `(4 5 6)`을 더하면 어떻게 될까요?

Array는 둘을 하나로 연결합니다. `+` 연산이 수학의 덧셈과는 다르죠.

```ruby
[1, 2, 3] + [4, 5, 6]
# => [1, 2, 3, 4, 5, 6]
```

NMatrix를 이용해서 벡터를 표현하는 건 다음과 같습니다.

```ruby
v = N[1, 2, 3]
v.to_a # => [1, 2, 3]
# 내용을 확인하기 위해서 to_a 활용!
```

벡터의 덧셈을 확인해 봅시다.

```ruby
(N[1, 2, 3] + N[4, 5, 6]).to_a
# => [5, 7, 9]
```

고등학교 수학 시간에 “행렬과 벡터” 단원을 들으신 분들은 이게 올바른 벡터의 덧셈이란 걸 아실 겁니다.

두 벡터의 크기가 다른 상황을 Array와 NMatrix를 활용해서 비교해 볼까요?

```ruby
[1, 2, 3] + [4, 5, 6, 7] # => [1, 2, 3, 4, 5, 6, 7]
N[1, 2, 3] + N[4, 5, 6, 7] # => ArgumentError
```

벡터의 크기가 다르면 덧셈이 되지 않습니다.

벡터와 스칼라를 더하면 어떻게 될까요?

```ruby
[1, 2, 3] + 4 # => TypeError
(N[1, 2, 3] + 4).to_a # => [5, 6, 7]
```

우리가 수학 시간에 배운 걸 그대로 루비 코드로 옮길 수 있습니다.

훨씬 흥미로운 곱셈도 알아볼까요?

```ruby
a = N[1, 2, 3]
b = N[4, 5, 6]
(a * b).to_a # => [4, 10, 18]
(a.dot(b)).to_a # => 32
```

# Matrix

이번에는 행렬을 사용해 보도록 하죠.

```ruby
m = N[[1, 2, 3], [4, 5, 6]]
m.shape # => [2, 3]
m[0, 0] # => 1
m[0, 1] # => 2
m[1, 0] # => 4
m[1, 2] # => 6
m.row(0).to_a # => [1, 2, 3]
m.column(0).to_a.flatten # => [1, 4]
m.transpose.to_a # => [[1, 4], [2, 5], [3, 6]]
```

행렬의 곱셈은 내적을 활용합니다. 반드시 `(m x n)`과 `(n x q)` 순서로 크기를 맞춰서 곱해야 한다는 건 아시죠?

```ruby
a = N[[1, 1, 1], [2, 2, 2]]
b =  N[[1, 2], [3, 4], [5, 6]]
a.shape # => [2, 3]
b.shape # => [3, 2]
c = a.dot(b)
c.to_a # => [[9, 12], [18, 24]]
a.dot(a) # => ArgumentError
```

## 여러 데이터를 한번에 계산

행렬의 가장 기본적인 활용법을 알아보죠. 벡터의 합을 간단히 구해봅시다.

```ruby
[1, 2, 3, 4, 5].reduce(&:+) # => 15
N[[1, 2, 3, 4, 5]].dot(N[[1] * 5].transpose).to_a # => [15]
```

이번엔 여러 학생의 성적을 과목별로 가중치를 줘서 더해볼까요?

```ruby
weights = [1.0, 0.5, 2.0]
students = [
  [100, 80, 50],
  [50, 60, 70],
  [10, 10, 10],
  [100, 100, 100]
]
# 가중치가 없을 때
students.map { |i| i.reduce(&:+) }
N[*students].dot(N[[1] * 3].transpose).to_a.flatten
# 가중치 적용
students.map { |i| i.zip(weights).map { |i| i.reduce(&:*) }.reduce(&:+) }
students.to_nm.dot(N[weights].transpose).to_a.flatten
# to_nm을 쓰면 쉽게 행렬로 바꿀 수 있습니다.
```

이 경우, NMatrix를 사용하면 두 가지를 얻을 수 있습니다.

1. 여러 번 계상해야 하는 게 한번에 끝남.
2. 연산이 네이티브로 처리되기 때문에 빠름.

## 인공 신경망의 인공 뉴런 기초 연산

최근 핫한 딥러닝에서 최소 단위가 되는 노드를 만들어 봅시다. 여기서는 단층 퍼셉트론의 활성화 함수 적용 직전 단계를 만들어 볼까요?

사실 이건 별 거 아닌데, 그냥 평범한 일차 함수를 활용합니다.

```
y = a * x + b
```

그냥 수학적인 정의를 살짝만 바꿔서 불러보겠습니다. a 대신 weight, b 대신 bias란 용어를 써보죠.

```
y = w * x + b
```

신경망에선 입력값 x는 하나가 아니라 여럿입니다. 분류기 등으로 활용할 때, 출력값 y 또한 여럿이 됩니다(대개 확률 벡터로 사용됩니다). 행렬의 크기와 함께 표현하면 다음과 같이 볼 수 있습니다(n: 입력 벡터의 크기, k: 출력 벡터의 크기).

```
y(k x 1) = w(k x n) * x(n x 1) + b(k x 1)
```

신경망을 학습시키기 위해서는 여러 데이터를 넣어줄 필요가 있습니다. m개의 데이터를 넣는다고 가정하고, 행렬 x의 방향을 조금 바꾸겠습니다(그러면 곱셈 순서가 바뀌죠).

```
y(m x k) = x(m x n) * w(n x k) + b(m x k)
```

이제 코드로 옮기는 일만 남았네요. m = 10, k = 3인 상황을 만들어 봅시다.

루비로 작성하면 다음과 같습니다:

```ruby
data = Array.new(100_000) { Array.new(10) { rand } }
w = Array.new(3) { Array.new(10) { rand } }
b = Array.new(3) { rand }
data.map do |items|
  w.map { |weights|
    items.zip(weights).map { |i| i.reduce(&:*) }.reduce(&:+)
  }.zip(b).map { |i| i.reduce(&:+) }
end
```

NMatrix를 활용하면 다음과 같습니다:

```ruby
data = N.random([100_000, 10])
w = N.random([10, 3])
b = N.random([1, 3])
data.dot(w) + b.repeat(100_000, 0) # bias의 형태를 맞춰주기 위해 열 반복
```

많은 데이터를 간단히, 더 빠르게 연산할 수 있죠?

제 New MacBook에서 둘의 성능을 비교하면 다음과 같이 나옵니다. NMatrix를 사용하는 쪽이 8배 정도 빠르네요.

```
  2.410000   0.020000   2.430000 (  2.435563)
  0.320000   0.010000   0.330000 (  0.332407)
```

소스 코드: [https://github.com/ahastudio/CodingLife/tree/master/20161211/sciruby](http://j.mp/2haojvm)

## 정리하며

루비는 기본적인 자료구조를 다룰 때 매우 강력합니다. 우리는 이런 자료구조 중심의 사고에 익숙하지요. 하지만 종종 수학적인 사고가 필요할 때가 있습니다. 그럴 땐 우리가 사용하는 도구도 수학적으로 동작하면 크게 도움이 됩니다.

NMatrix는 단순히 수학 연산을 쉽고 빠르게 수행하는 것 외에도, 우리가 프로그래밍할 때 수학적 사고를 하도록 도와주는 힘이 있다고 생각합니다. 우리가 기존에 작성하던 코드 가운데 수학적인 접근이 더 강력한 경우가 있을까요? 어떻게 하면 더 나은 방식으로 완전히 탈바꿈할 수 있을까요?

더 흥미로운 점을 발견하셨다면, ahastudio 앳 지메일닷컴으로 메일을 보내주세요. 피드백과 질문도 환영합니다.

---

- [2016년 한국 루비 커뮤니티 대림절 달력(Advent Calendar)](http://j.mp/1jL0Eir)
- 이전 글: 12월 10일, [루비 메서드 디스패치 시스템 이해하기 (Part 1)](http://j.mp/2hrF2s0)
- 다음 글: 12월 12일, [테스트 헬퍼 만들기](http://j.mp/2hjKUpw)
