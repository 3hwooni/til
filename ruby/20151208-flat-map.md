# Play with FlatMap

## 저자
[@ahastudio](http://j.mp/1ea27KW) - 우아한형제들에서 Ruby on Rails로 LINE WOW를 개발했고, 최근엔 Java와 Spring Boot로 배달의민족 신규시스템을 개발하고 있습니다.

## 시작하며
루비가 가지는 강점 중 하나는 블럭과 클로저를 활용한 함수형 프로그래밍이 가능하다는 점이라고 생각합니다. 이때 가장 많이 활용되는 게 `map`인데, 비슷한 것 같지만 약간 다르게 돌아가는 `flat_map`이란 것도 있습니다. 이걸로 어떤 재밌는 일을 벌일 수 있는지 확인해 볼까요?

## 준비물
- Ruby
- 흥미
- 용기
- 사랑과 우정 (필수는 아님)

## 배열 속의 검은 배열
입 속의 검은... 아니, 배열 속의 배열을 쓰기 좋게 단순한 배열로 만들어 봅시다. 이번에도 간단히 REPL을 쓰겠습니다.

```
$ irb
```

```ruby
[[1, 2, 3], [4, 5]].flatten
```

결과:
```
 => [1, 2, 3, 4, 5]
```

여기까지는 많이 해보셨을 거라고 생각합니다.

## Map과 Flatten의 만남
이번엔 간단히 구구단을 만들어 보죠. 너무 길면 귀찮으니 숫자는 9가 아니라 4까지만 진행합니다.

```ruby
[*2..4].map { |i| [*1..4].map { |j| "#{i} * #{j} = #{i * j}" } }
```

결과:
```
 => [["2 * 1 = 2", "2 * 2 = 4", "2 * 3 = 6", "2 * 4 = 8"], ["3 * 1 = 3", "3 * 2 = 6", "3 * 3 = 9", "3 * 4 = 12"], ["4 * 1 = 4", "4 * 2 = 8", "4 * 3 = 12", "4 * 4 = 16"]]
```

배열 속에 배열이 들어있어서 우리가 원하는 모양이 아닌 것 같습니다. `flatten`을 써볼까요?

```ruby
[*2..4].map { |i| [*1..4].map { |j| "#{i} * #{j} = #{i * j}" } }.flatten
```

결과:
```
 => ["2 * 1 = 2", "2 * 2 = 4", "2 * 3 = 6", "2 * 4 = 8", "3 * 1 = 3", "3 * 2 = 6", "3 * 3 = 9", "3 * 4 = 12", "4 * 1 = 4", "4 * 2 = 8", "4 * 3 = 12", "4 * 4 = 16"]
```

최종 결과물을 재가공한다는 게 맘에 들지 않습니다. Map과 동시에 배열을 벗겨내는 난폭한 메서드가 있다면 얼마나 좋을까요? 이때 `flat_map`이 출동합니다. `flat_map`의 위치에 주의하면서 보세요.

```ruby
[*2..4].flat_map { |i| [*1..4].map { |j| "#{i} * #{j} = #{i * j}" } }
```

결과:
```
 => ["2 * 1 = 2", "2 * 2 = 4", "2 * 3 = 6", "2 * 4 = 8", "3 * 1 = 3", "3 * 2 = 6", "3 * 3 = 9", "3 * 4 = 12", "4 * 1 = 4", "4 * 2 = 8", "4 * 3 = 12", "4 * 4 = 16"]
```

## FlatMap vs. Map+Flatten
`flat_map`과 `map`+`flatten` 조합은 조금 다릅니다. 간단한 예제를 통해 확인하고 넘어가죠.

```ruby
[[1, 2], 3].map { |i| [i] }.flatten
```

결과:
```
 => [1, 2, 3]
```

```ruby
[[1, 2], 3].flat_map { |i| [i] }
```

결과:
```
 => [[1, 2], 3]
```

## 일이 하나, 이는 둘, 삼은 셋
간단한 프로그램을 작성해 봅시다. 다음과 같은 수열을 Array로 돌려주는 프로그램을 만들려면 어떻게 해야 할까요?

```
1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5
```

이럴 때 `flat_map`을 쓰면 너무 간단히 끝나게 됩니다.

```
[*1..5].flat_map { |i| [i] * i }
```

결과:
```
 => [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]
```

어때요, 참 쉽죠?

## 공즉색
이번에는 1부터 10까지 숫자 중 짝수만 모아봅니다. `select`나 `reject` 없이 해봅시다.

이 경우에도 `flat_map`을 쓸 수 있을까요?

(아래로 넘어가기 전에 직접 풀어보세요!)

네, 가능합니다.

```ruby
[*1..10].flat_map { |i| i.even? ? [i] : [] }
```

결과:
```
 => [2, 4, 6, 8, 10]
```

무슨 일이 벌어진 걸까요? 우리는 빈 배열(`[]`)을 통해 무(無)를 표현할 수 있게 됐습니다. `nil`과 다른 의미를 전달할 수 있는 수단을 얻게 된 것이죠.

## NullObject?
우리는 종종 불가능한 상황을 함께 다뤄야 합니다. jQuery를 써보신 분은 다음과 같은 코드가 언제나 오류 없이 돌아갈 수 있다는 걸 아실 겁니다.

```javascript
$('#hello').find('span').addClass('active').removeClass('invalid');
```

이 코드는 ID가 hello인 element가 있냐 없냐, 그 아래에 span이 있냐 없냐 같은 걸 전혀 고려하지 않아도 잘 작동하지요. 방어적인 프로그래밍을 하기 위해 Null Object Pattern 등을 도입하기로 하는데, 인터페이스를 맞춰줘야 한다는 부담(?)이 있습니다.  여기선 FlatMap과 비어있는 배열을 이용해 문제를 해결해 보겠습니다.

일단 문제가 있는 코드를 만들어 보죠.

```ruby
f = { a: 1, c: 3 }
[:a, :b, :c, :d].map { |i| f[i] }.map { |i| i + 3 }
```

간단히 `flat_map`을 사용합니다.

```ruby
f = { a: 1, c: 3 }
[:a, :b, :c, :d].flat_map { |i| f[i] || [] }.map { |i| i + 3 }
```

결과:
```
 => [4, 6]
```

`f` 자체를 바꿔주면 더 좋겠죠?

```ruby
f = -> (x) { { a: 1, c: 3 }[x] || [] }
[:a, :b, :c, :d].flat_map { |i| f[i] }.map { |i| i + 3 }
```

## 정리하며
우리는 메서드를 어떤 기능으로만 바라볼 때가 많습니다. 하지만, 그 기능을 잘 살펴보면 우리의 표현을 확장할 기회를 얻기도 합니다. FlatMap 등으로 다른 표현을 얻고, 이를 통해 다양한 관점으로 문제를 볼 수 있는 즐거운 여행이었길 바랍니다. 자, 또 다른 관점은 뭐가 있을까요?

**EOT**
